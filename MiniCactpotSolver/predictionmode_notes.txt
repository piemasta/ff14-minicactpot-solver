        /*Logic:
         * 
         * The goal is to find the Cactpot line with 100% confidence within 4 moves, the first of which is done for us by the ticket guy.
         * We can't base our selections on directly trying to find the Cactpot, there just isn't any information available to us that
         * will help. Any tile is equally likely to be a 1, 2 or 3, at all stages. Instead we can attempt to corner a Cactpot, if it
         * exists, by pursuing the opposite outcome. We try to find the lines that absolutely cannot be a Cactpot. Luckily this is
         * much easier, any line found to contain a number that is not 1, 2 or 3 cannot win a Cactpot. It also happens that we can
         * easily eliminate multiple lines per round. It's just a matter of picking the right tiles to optimize eliminations.
         * 
         * Also, since directly pursuing information about the Cactpot - any tile with 1, 2, or 3 - yields us no advantage, assuming
         * that every tile will instead result in the opposite guarantees that we attain at least as much information as we set out to.
         * As a bonus, there's also that fixed probability that we actually uncover a 1, 2, or 3, which will only help us narrow it
         * down more quickly.
         * 
         * Here's the deal. Every tile that is uncovered that isn't a Cactpot number (1, 2, or 3) yields us bits of information about
         * where the Cactpot isn't. Once we uncover one of those numbers, we try to avoid choosing tiles that lie on the same line as
         * it, because we've already eliminated that line. So, even though we're technically looking for them, non-Cactpot numbers
         * that we've already uncovered act as barriers against our search for information. Each non-Cactpot number on the board
         * greatly reduces our options as far as efficiency is concerned. On the other hand, Cactpot numbers don't have this effect.
         * Any line with a Cactpot number on it is not eliminated (unless that line has another, non-Cactpot number on it as well) and
         * so it's presence doesn't reduce our options from a probability standpoint. It will however influence our next move, albeit
         * without hurting us. Since it's the Cactpot we're trying to find in the end, and since we don't have unlimited rounds, we do
         * need to pursue it directly once we have a lead. We do this by choosing the tile that eliminates the most lines, but is also
         * on a line with the Cactpot number. This will doubtless lead to times where we sacrifice raw information, but it is
         * imperative that we attempt to eliminate the Cactpot lines as quickly as possible. The sooner we can prove it's existence
         * (or non-existence), the more time we'll have to rally and chase one of the mini-pots instead.
         *
         * */

		//123           1   2   3   4   5   6   7   8   9           1   [3] 1, 6, 7
        //456           3   2   3   2   4   2   3   2   3           2   [2] 1, 5
        //789                                                       3   [3] 1, 4, 8
        //369                                                       4   [2] 2, 6
        //258                                                       5   [4] 2, 5, 7, 8
        //147                                                       6   [2] 2, 4
        //159                                                       7   [3] 3, 6, 8
        //357                                                       8   [2] 3, 5
        //                                                          9   [3] 3, 4, 7
		   
		//      0       0       5                        -->        down         dl          dr
        //                                              0 0 5       5 0 0       5 0 0       0 0 0
        //      1       0       0           --          1 0 0       0 0 0
        //                                              0 0 0       0 1 0
        //      0       0       0

        //              |

        //      2       1       x
        //
        //      x       3       1
        //
        //      2       2       2

        // If a line has only cactpot numbers and empty tiles, increment every empty tile in that row. The tile(s) with the highest
        // value after investigating every row are the result of this algorithm. All tiles in the result set have the same weight, the
        // algorithm makes no distinction between them.

        //Indices           012
        //                  345
        //                  678
        //                  036
        //                  147
        //                  048
        //                  246

		        /*@index
         * 0 1 2  [row 0] 
         * 3 4 5  [row 1] 
         * 6 7 8  [row 2]                   0   1   2       3   2   3
         * 0 3 6  [row 3] 
         * 1 4 7  [row 4]                   3   4   5   ->  2   4   2
         * 2 5 8  [row 5] 
         * 0 4 8  [row 6]                   6   7   8       3   2   3
         * 2 4 6  [row 7] 
         * 
         * @member_index
         * [tile 0] is in rows 0, 3, 6
         * [tile 1] is in rows 0, 4
         * [tile 2] is in rows 0, 5, 7
         * [tile 3] is in rows 1, 3
         * [tile 4] is in rows 1, 4, 6, 7
         * [tile 5] is in rows 1, 5
         * [tile 6] is in rows 2, 3, 7
         * [tile 7] is in rows 2, 4
         * [tile 8] is in rows 2, 5, 6
         * */

		         #region backup member_index
        ////Tracks the relationship between each @grid tile and the group of @row's it belongs to, associated firstly by @grid index, and secondly by row index.
        //private static int[][] member_index = { new int[]{ 0, 5, 6 }, new int[]{ 0, 4 },        // multi-dimensional, staggered (9)(2-4, values are rowLength)
        //                                        new int[]{ 0, 3, 7 }, new int[]{ 1, 5 },
        //                                        new int[]{ 1, 4, 6, 7 },
        //                                        new int[]{ 1, 4 }, new int[]{ 2, 5, 7 },
        //                                        new int[]{ 2, 4 }, new int[]{ 2, 3, 6 } };
        #endregion
		   
		    //start the game like normal, wait for (or somehow prompt) the user for the first tile
            
            //once a single tile has been entered, lock the board from further entries until the prediction algorithm runs
            //LockBoard() -> remove keydown and keypress eventhandlers to form
            //UnlockBoard() -> add keydown and keypress eventhandlers to form

            //signal to user (by altering tile image) which tile the algorithm suggests
            //wait for user to input a second tile entry (if they clear the first entry, proceed from previous step)
            //once second tile is entered, lock board, run algorithm and show prediction, unlock board, wait for user input
            //repeat until 4 tiles are uncovered

            //once 4 tiles are uncovered, prediction algorithm will suggest a row
            //allow user to regress tile selections as before, or signal the game to reset

            //add flags to SetButtonToBlank and SetButtonToNumber to detect relevant user action
            // SetButtonToNumber can set a flag if user flips a new tile
            // SetButtonToBlank can set a flag if user clears a tile that was previously uncovered

            //          (we can task Register and Unregister with maintaining a count of registered tiles)

            //then we can check these flags each loop iteration
            //if user flipped a new tile, lock board, run algorithm and show prediction, unlock board, ->next loop
            //if user cleared an uncovered tile, AND if all tiles aren't still covered (tiles_showing != 0) then lock, predict, unloc
            
            //          if all tiles are covered at this point, simply wait for input (which is the start of the loop)
            //                  ^- this means to skip the current iteration of prediction, so use 'continue'

            //TODO
            //add and implement registered tiles counter -                  DONE -> tilesRegistered
            //add and implement new_tile and cleared_tile flags             DONE -> user_revealed_tile *and* user_covered_tile
            //      ^- remember to clear them after use
            //implement PromptUserForInput method                           TEMP -> placeholder loop is implemented
            //implement LockBoard() and UnlockBoard()

            /*
             * Pseudocode for PredictionMode execution loop
             * 
             * while(true)
             * {
             *      user_revealed_tile = false;
             *      user_covered_tile = false;
             *      
             *      Prompt_user_for_input(); //includes a loop with sleep() somewhere in it
             *      
             *         ->   while(!user_revealed_tile && !user_covered_tile)
             *              {
             *                  sleep(100);
             *              }
             *      
             *      if( cleared_tile_flag && tilesRegistered == 0 )
             *      {
             *          continue;
             *      }
             *      else if( New_tile_flag || cleared_tile_flag )
             *      {
             *          LockBoard();
             *          int predic = PredictionAlgorithm(board);
             * 
             *          //Can check any conditions for prediction result
             * 
             *          ShowPrediction(predic);
             *          UnlockBoard();
             *          continue;
             *      }
             *      else
             *      {
             *          //something went wrong, log it
             *      }
             *      
             * 
             * 
             * }
             * 
             * 
             * 
             * */



			 Minipot_Potential

			 //takes one tile at a time (fed by result of elimination yield algorithm)
            //somehow grant a relative weight to each tile with regard to its value toward winning a minipot should the cactpot not proc.

            //will need to mathematically examine the number distribution across the payout board, some numbers may be
            //inherently more valuable than others.

       X     //the brute force method
       X     //take all remaining possible sums for each line, match them with their respective pots and add up the total for each line.
       X     //since the probabilities for getting any particular pot in an arbitrary line with covered tiles remaining are all equal,
       X     //we should also pay attention to the relative chance to score a sizeable minipot, as opposed to the garbage payouts.
       X     //This should result in an overall higher average payout for games where the cactpot is not possible.
									^- ** we're computing a rating for a single tile, albeit with regard to possible payout results
																									(which is a line property)

            //is it easier to do them all at once? or one at a time.
            //to do a single tile, we'll need to account for the weight of all of the lines it sits on (up to 4)
            //      brute forcing them all could take a long time, do them individually as needed

            //Need array to count number of times a payout tier is reached when brute forcing line_sum. 
            //          ^- can be local     DONE
            //  Need function or data structure to manage which numbers are still available. Possibly delivered as a mask of sorts
            //  to the *brute loop*.          ^-can also be local     DONE -> enum Numbers (_1, _2..) and GenerateMask

            //go through each pertinent row
            //anything thats zero, count
            //anything not zero, add to the line sum
            //for each count, add all remaining possible combinations of numbers to the total
            //      ^- also count how many times the line_sum equals each payout

            //members[] contains the number of rows each tile belongs to
            //member_index[][] contains the row index numbers for each tile
            //          ^- probably has member_index[].Length which would replace members[]

			        /*This function must be aggressively tested.                            *******************************************
         *                                                                      ///////////////////////////////////////////
         *    Seems to be working. Make sure it's not duplicating numbers for   ///////////////////////////////////////////
         *    any of it's loops. Then work on fine-tuning and getting it        ///////////////////////////////////////////
         *    hooked up to the rest of the program.                             *******************************************
         *    
         *  The brute loops consider all combinations* (instead of permutations) of possible line sums. Combinations is calculated
         *  as follows:         *  
         *              (n P r)                      n!                         n!         
         *    (n C r) = -------   where (n P r) = -------    ->   (n C r) = -----------  for (n) objects taken (r) at a time.
         *                 r!                      (n - r)!                 r! (n - r)!
         * 
         * So the number of iterations required to determine the rating contribution of a line with 3 empty tiles is:
         * 
         *                   9!            9!        (9 * 8 * 7 * 6 * 5 * 4 * 3 * 2)      (9 * 8 * 7)       504
         *    (9 C 3) = -----------  =  -------  =  --------------------------------  =  -------------  =  -----  =  84
         *              3! (9 - 3)!      3! 6!        (3 * 2) * (6 * 5 * 4 * 3 * 2)         (3 * 2)          6
         * 
         * For a line with 2 empty tiles:                               And for a line with only 1 empty tile:
         * 
         *                 8!       (8 * 7)      56                                        7!     
         *    (8 C 2) = -------  =  -------  =  ----  =  28                   (7 C 1) = -------  =  7
         *               2! 6!         2          2                                      1! 6!  
         *               
         * The maximum number of iterations to complete a rating for a single input tile is 336.
         * The maximum number of iterations to complete a rating for each tile on the board is 3024.
         * */

		 
        /* Calculate_Minipot_Potential needs to be rewritten to accept and calculate the total potential for a row, an element
         * from @rows.
         * 
         * Whereas the tile override of Calculate_Minipot_Potential calculates the potential rating of a given tile, this override will
         * need to calculate the potential rating for each entire line. This is more complicated than simply summing each row
         * from @pots. For each row, we must get the Minipot potential rating for all empty tiles, each of which is individually
         * based on all currently uncovered tiles. Except this time everytime we calculate the potential for a tile in a given
         * row we'll need to do all future calculations for that row iteration as if that tile were now uncovered, since that
         * tiles value will now affect the outcome of any further rating calculations for this row.
         * 
         * Gonna need to do permutations instead of combinations for this method as well. Much brute loop.
         * 
         * */

		IsCactpotPossible()

		count == 2

		/*if original_grid_index is 0 (cactpot number is in top left tile)
                         *  then we're looking at member_index[0] -> { 0, 5, 6 }
                         *
                         *when we loop through this row[] (at @row index -> member_index[][])
                         *  the loop has member_index[0].Length iterations (3)
                         *  each row[] element is at index row[][j]    -> where j is the loop counter
                         *
                         *since each @row[][j] holds a grid 'value', this is what we pass to IsEmpty, to check if the value is zero (blank tile)
                         *
                         *steps:
                         *the original_grid_index[0] = 0
                         *      so member_index[original_grid_index[0]] points to { 0, 5, 6 } and has .Length = 3 (our loop limiter)
                         *      -> our loop variable is 'i', so
                         *              each member of { 0, 5, 6 } is referenced by ( member_index[ original_grid_index[0] ] ) [i]
                         *              -> which is the index of the @row[] we need.
                         *              -> the first row we grab from @member_index[][] is @row[0] which is -> { 0, 1, 2 } and always has .Length = 3 (our next loop limiter)
                         *              -> our next loop variable is 'j', so                     [                                                  ]
                         *                      each element of { 0, 1, 2 } is referenced by @row[   member_index[ original_grid_index[0] ]   [i]   ] [j]
                         *                                                                       [                                                  ]       
                         *                      -> this is the value we sent to IsEmpty()
                         *                                                                       [                                                  ]
                         *                                                                   @row[   member_index[ original_grid_index[0] ]   [i]   ] [j] 
                         *                                                                       [                                                  ]
                         *if any row of which the cactpot tile is a member has 2 empty tiles, cactpot is still possible
                         * */